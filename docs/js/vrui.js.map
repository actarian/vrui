{"version":3,"names":[],"mappings":"","sources":["src/js/vrui.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, THREE */\n\n// import * as THREE from 'three';\n// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\nimport { cm, TEST_ENABLED } from './const';\nimport InteractiveMesh from './interactive/interactive.mesh';\nimport Controllers from './vr/controllers';\nimport { GAMEPAD_HANDS } from './vr/gamepads';\nimport { VR, VR_MODE } from './vr/vr';\n\nclass vrui {\n\n\tconstructor() {\n\t\tthis.tick = 0;\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.cameraDirection = new THREE.Vector3();\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tconst section = this.section = document.querySelector('.vrui');\n\t\tconst container = this.container = section.querySelector('.vrui__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\t\tconst debugSave = this.debugSave = section.querySelector('.debug__save');\n\n\t\tconst renderer = this.renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t});\n\t\trenderer.setClearColor(0x666666, 1);\n\t\trenderer.setPixelRatio(window.devicePixelRatio);\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\trenderer.vr.enabled = true;\n\t\tcontainer.appendChild(renderer.domElement);\n\n\t\tconst vr = this.vr = new VR(renderer, { referenceSpaceType: 'local' }, (error) => {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t});\n\t\tcontainer.appendChild(vr.element);\n\n\t\tconst raycaster = this.raycaster = new THREE.Raycaster();\n\n\t\tconst scene = this.scene = new THREE.Scene();\n\n\t\tconst camera = this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t\tcamera.position.set(0, cm(176), 0);\n\t\tcamera.target = new THREE.Vector3(0, cm(176), -2);\n\t\tcamera.lookAt(camera.target);\n\n\t\t/*\n\t\tconst light = new THREE.HemisphereLight(0xffffff, 0x000000, 1);\n\t\tscene.add(light);\n\t\t*/\n\n\t\tconst hdr = this.hdr = this.getEnvMap((texture, textureData) => {});\n\n\t\tconst bg = this.bg = this.addBG();\n\t\tscene.add(bg);\n\n\t\tconst cube0 = this.cube0 = this.addCube(0);\n\t\tscene.add(cube0);\n\n\t\tconst cube1 = this.cube1 = this.addCube(1);\n\t\tscene.add(cube1);\n\n\t\tif (this.vr.mode !== VR_MODE.NONE || TEST_ENABLED) {\n\t\t\tconst controllers = this.controllers = new Controllers(renderer, scene, {\n\t\t\t\tdebug: true\n\t\t\t});\n\t\t\tcontrollers.on('press', (button) => {\n\t\t\t\tconsole.log('vrui.press', button.gamepad.hand, button.index);\n\t\t\t\tswitch (button.gamepad.hand) {\n\t\t\t\t\tcase GAMEPAD_HANDS.LEFT:\n\t\t\t\t\t\t// 0 joystick, 1 trigger, 2 grip, 3 Y, 4 X\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tswitch (button.index) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GAMEPAD_HANDS.RIGHT:\n\t\t\t\t\t\t// 0 joystick, 1 trigger, 2 grip, 3 A, 4 B\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\tcontrollers.on('release', (button) => {\n\t\t\t\tconsole.log('vrui.release', button.gamepad.hand, button.index);\n\t\t\t});\n\t\t\tcontrollers.on('left', (axis) => {\n\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\tconsole.log('vrui.left', axis.gamepad.hand, axis.index);\n\t\t\t\t\tTweenMax.to(cube0.userData.rotation, 0.3, {\n\t\t\t\t\t\ty: cube0.userData.rotation.y - Math.PI / 2,\n\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tcontrollers.on('right', (axis) => {\n\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\tconsole.log('vrui.right', axis.gamepad.hand, axis.index);\n\t\t\t\t\tTweenMax.to(cube0.userData.rotation, 0.3, {\n\t\t\t\t\t\ty: cube0.userData.rotation.y + Math.PI / 2,\n\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tcontrollers.on('up', (axis) => {\n\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\tconsole.log('vrui.up', axis.gamepad.hand, axis.index);\n\t\t\t\t\tconst s = Math.min(2.0, cube0.userData.scale.x + 0.1);\n\t\t\t\t\tTweenMax.to(cube0.userData.scale, 0.3, {\n\t\t\t\t\t\tx: s,\n\t\t\t\t\t\ty: s,\n\t\t\t\t\t\tz: s,\n\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tcontrollers.on('down', (axis) => {\n\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\tconsole.log('vrui.down', axis.gamepad.hand, axis.index);\n\t\t\t\t\tconst s = Math.max(0.1, cube0.userData.scale.x - 0.1);\n\t\t\t\t\tTweenMax.to(cube0.userData.scale, 0.3, {\n\t\t\t\t\t\tx: s,\n\t\t\t\t\t\ty: s,\n\t\t\t\t\t\tz: s,\n\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tcontrollers.on('axis', (axis) => {\n\t\t\t\tconsole.log('vrui.axis', axis.gamepad.hand, axis.index);\n\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.RIGHT) {\n\t\t\t\t\tconst s = Math.max(0.1, Math.min(2, cube1.scale.x + axis.y * 0.1));\n\t\t\t\t\tcube1.userData.scale.set(s, s, s);\n\t\t\t\t\tcube1.userData.rotation.y += axis.x * 0.2;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t}\n\n\taddCube(index) {\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-00.jpg');\n\t\tconst geometry = new THREE.BoxGeometry(cm(20), cm(20), cm(20));\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: matcap,\n\t\t});\n\t\tconst cube = new InteractiveMesh(geometry, material);\n\t\tcube.position.set(index === 0 ? -cm(30) : cm(30), cm(136), -2);\n\t\tcube.userData = {\n\t\t\tscale: new THREE.Vector3(1, 1, 1),\n\t\t\trotation: new THREE.Vector3(),\n\t\t\t// position: new THREE.Vector3(),\n\t\t};\n\t\tcube.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {\n\t\t\tcube.scale.set(cube.userData.scale.x, cube.userData.scale.y, cube.userData.scale.z);\n\t\t\tcube.rotation.set(cube.userData.rotation.x, cube.userData.rotation.y, cube.userData.rotation.z);\n\t\t\t/*\n\t\t\tcube.rotation.y += Math.PI / 180 * 5;\n\t\t\tcube.rotation.x += Math.PI / 180 * 1;\n\t\t\tconst s = 1 + Math.cos(this.tick * 0.1) * 0.5;\n\t\t\tcube.scale.set(s, s, s);\n\t\t\t*/\n\t\t};\n\t\tcube.on('over', () => {\n\t\t\tcube.material.color.setHex(0xffffff);\n\t\t});\n\t\tcube.on('out', () => {\n\t\t\tcube.material.color.setHex(0xcccccc);\n\t\t});\n\t\tcube.on('down', () => {\n\t\t\tcube.material.color.setHex(0x0000ff);\n\t\t});\n\t\tcube.on('up', () => {\n\t\t\tcube.material.color.setHex(0xcccccc);\n\t\t});\n\t\treturn cube;\n\t}\n\n\taddBG() {\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-10.jpg');\n\t\tconst geometry = new THREE.Geometry();\n\t\tconst origin = new THREE.Vector3();\n\t\tnew Array(300).fill().forEach(x => {\n\t\t\tconst s = cm(30) + Math.random() * cm(0);\n\t\t\tconst h = 3.0 + Math.random() * 3.0;\n\t\t\tconst r = 5 + Math.random() * 20;\n\t\t\tconst a = Math.PI * 2 * Math.random();\n\t\t\tconst cubeGeometry = new THREE.BoxGeometry(s, h, s);\n\t\t\tcubeGeometry.translate(Math.cos(a) * r, h / 2, Math.sin(a) * r);\n\t\t\tcubeGeometry.lookAt(origin);\n\t\t\tgeometry.merge(cubeGeometry);\n\t\t});\n\t\tconst bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0x333333,\n\t\t\tmatcap: matcap,\n\t\t});\n\t\tconst mesh = new THREE.Mesh(bufferGeometry, material);\n\t\t/*\n\t\tmesh.onBeforeRender = () => {\n\t\t\tmesh.rotation.y += 0.001;\n\t\t};\n\t\t*/\n\t\treturn mesh;\n\t}\n\n\tgetEnvMap(callback) {\n\t\tconst loader = new THREE.TextureLoader().load('img/environment/360_world.jpg', (source, textureData) => {\n\t\t\tsource.mapping = THREE.UVMapping;\n\t\t\tconst options = {\n\t\t\t\tresolution: 1024,\n\t\t\t\tgenerateMipmaps: true,\n\t\t\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter\n\t\t\t};\n\t\t\tthis.scene.background = new THREE.CubemapGenerator(this.renderer).fromEquirectangular(source, options);\n\t\t\tconst cubemapGenerator = new THREE.EquirectangularToCubeGenerator(source, options);\n\t\t\tconst texture = cubemapGenerator.update(this.renderer);\n\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\ttexture.mapping = THREE.CubeRefractionMapping;\n\t\t\tsource.dispose();\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tcallback(texture);\n\t\t\t}\n\t\t});\n\t\treturn loader;\n\t}\n\n\tupdateRaycaster() {\n\t\ttry {\n\t\t\tconst controllers = this.controllers;\n\t\t\tconst raycaster = controllers.setRaycaster(this.raycaster);\n\t\t\tif (raycaster) {\n\t\t\t\tconst hit = InteractiveMesh.hittest(raycaster, controllers.gamepads.button);\n\t\t\t\tif (hit) {\n\t\t\t\t\tcontrollers.feedback();\n\t\t\t\t\t/*\n\t\t\t\t\tif (Tone.context.state === 'running') {\n\t\t\t\t\t\tconst feedback = this.feedback = (this.feedback || new Tone.Player('audio/feedback.mp3').toMaster());\n\t\t\t\t\t\tfeedback.start();\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\trender(delta) {\n\t\ttry {\n\t\t\tif (this.controllers) {\n\t\t\t\tthis.controllers.update();\n\t\t\t\tthis.updateRaycaster();\n\t\t\t}\n\t\t\tconst renderer = this.renderer;\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t\tthis.tick++;\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() => {\n\t\t\tthis.render();\n\t\t});\n\t}\n\n\tonWindowResize() {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst width = container.offsetWidth;\n\t\t\tconst height = container.offsetHeight;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(width, height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n}\n\nconst tour = new vrui();\ntour.animate();\n"],"file":"docs/js/vrui.js"}