{"version":3,"names":[],"mappings":"","sources":["src/js/vrui.js"],"sourcesContent":["/* jshint esversion: 6 */\n\n// import * as THREE from 'three';\n// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\nimport { BOUNDING_BOX, cm, DEBUG, deg, mm, TEST_ENABLED, TRIGGER_CUBES } from './const';\nimport RoundBoxGeometry from './geometries/round-box.geometry';\nimport FreezableGroup from './interactive/freezable.group';\nimport FreezableMesh from './interactive/freezable.mesh';\nimport GrabbableGroup from './interactive/grabbable.group';\nimport InteractiveMesh from './interactive/interactive.mesh';\nimport Materials from './materials/materials';\n// import Physics from './physics/physics';\nimport PhysicsWorker from './physics/physics.worker';\nimport Controllers from './vr/controllers';\nimport { GAMEPAD_HANDS } from './vr/gamepads';\nimport { VR, VR_MODE } from './vr/vr';\n\nclass Vrui {\n\n\tconstructor() {\n\t\tthis.tick = 0;\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.clock = new THREE.Clock();\n\t\tthis.linearVelocity = new THREE.Vector3();\n\t\tthis.angularVelocity = new THREE.Vector3();\n\t\t// this.size = { width: 0, height: 0, aspect: 0 };\n\t\t// this.cameraDirection = new THREE.Vector3();\n\t\t//\n\t\tconst section = this.section = document.querySelector('.vrui');\n\t\tconst container = this.container = section.querySelector('.vrui__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\t\tconst debugSave = this.debugSave = section.querySelector('.debug__save');\n\t\tconst renderer = this.renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t});\n\t\trenderer.setClearColor(0xdfdcd5, 1);\n\t\trenderer.setPixelRatio(window.devicePixelRatio);\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.shadowMap.type = THREE.PCFShadowMap; // THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap\n\t\trenderer.vr.enabled = true;\n\t\tcontainer.appendChild(renderer.domElement);\n\n\t\tconst vr = this.vr = new VR(renderer, {\n\t\t\treferenceSpaceType: 'local'\n\t\t});\n\t\tvr.on('error', (error) => {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t});\n\t\tcontainer.appendChild(vr.element);\n\n\t\tconst raycaster = this.raycaster = new THREE.Raycaster();\n\n\t\tconst scene = this.scene = new THREE.Scene();\n\t\tscene.name = 'Scene';\n\t\t// const texture = this.addSceneBackground(renderer, scene, (texture, textureData) => {});\n\t\tthis.addSceneBackground(renderer, scene);\n\n\t\tconst camera = this.camera = this.addCamera();\n\t\tscene.add(camera);\n\n\t\tif (true) {\n\t\t\t// const light = new THREE.HemisphereLight(0xffffff, 0x330000, 1.2);\n\t\t\tconst light = new THREE.DirectionalLight(0xffffff, 1, 100);\n\t\t\tlight.position.set(0, 3, 0);\n\t\t\tlight.castShadow = true;\n\t\t\tscene.add(light);\n\t\t\tlight.shadow.mapSize.width = 1024;\n\t\t\tlight.shadow.mapSize.height = 1024;\n\t\t\tlight.shadow.radius = 1.25;\n\t\t\tlight.shadow.camera.near = 0.1;\n\t\t\tlight.shadow.camera.far = 100;\n\t\t\t/*\n\t\t\tconst helper = new THREE.CameraHelper(light.shadow.camera);\n\t\t\tscene.add(helper);\n\t\t\t*/\n\t\t}\n\n\t\tconst controllers = this.controllers = this.addControllers(renderer, vr, scene);\n\n\t\tthis.addListeners();\n\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\n\t\t// const physics = this.physics = new Physics();\n\t\tconst physics = this.physics = new PhysicsWorker();\n\t\tconst floor = this.floor = this.addFloor();\n\t\tscene.add(floor);\n\t\t/*\n\t\tphysics.on('init', () => {\n\t\t\tconsole.log('init');\n\t\t\tthis.addMeshes();\n\t\t});\n\t\t*/\n\t\tsetTimeout(() => {\n\t\t\t// const materials = this.materials = this.addMaterials(scene.background);\n\t\t\tconst materials = this.materials = new Materials(scene.background);\n\t\t\t/*\n\t\t\tconst bg = this.bg = this.addBG();\n\t\t\tscene.add(bg);\n\t\t\t*/\n\t\t\tthis.addMeshes();\n\t\t}, 1000);\n\n\t}\n\n\taddFloor() {\n\t\tif (this.physics) {\n\t\t\tconst geometry = new THREE.PlaneGeometry(40, 40);\n\t\t\tgeometry.rotateX(deg(-90));\n\t\t\tconst material = new THREE.ShadowMaterial();\n\t\t\tmaterial.opacity = 0.5;\n\t\t\tconst floor = new THREE.Mesh(geometry, material);\n\t\t\tfloor.position.y = 0.0;\n\t\t\tfloor.receiveShadow = true;\n\t\t\t/*\n\t\t\tconst floor = new THREE.Group();\n\t\t\tfloor.position.y = -0.1;\n\t\t\t*/\n\t\t\tthis.physics.addBox(floor, new THREE.Vector3(40, cm(1), 40));\n\t\t\treturn floor;\n\t\t}\n\t}\n\n\tupdateVelocity(controller) {\n\t\tif (controller) {\n\t\t\tthis.linearVelocity.copy(controller.linearVelocity).multiplyScalar(40);\n\t\t\tthis.angularVelocity.copy(controller.angularVelocity).multiplyScalar(10);\n\t\t}\n\t}\n\n\taddMeshes() {\n\t\tconst scene = this.scene;\n\t\t/*\n\t\tconst banner = this.banner = this.addBanner();\n\t\tscene.add(banner);\n\t\t*/\n\t\tif (TRIGGER_CUBES) {\n\t\t\tconst cube0 = this.cube0 = this.addRoundedCube(0);\n\t\t\tscene.add(cube0);\n\t\t\tconst cube1 = this.cube1 = this.addRoundedCube(1);\n\t\t\tscene.add(cube1);\n\t\t}\n\t\tconst stand = this.stand = this.addStand();\n\t\tscene.add(stand);\n\t\tconst toothbrush = this.toothbrush = this.addToothBrush();\n\t\tscene.add(toothbrush);\n\t}\n\n\taddListeners() {\n\t\tif (this.vr.mode === VR_MODE.NONE) {\n\t\t\tthis.onMouseDown = this.onMouseDown.bind(this);\n\t\t\twindow.addEventListener('mousedown', this.onMouseDown);\n\t\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t\t\twindow.addEventListener('mouseup', this.onMouseUp);\n\t\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\t\twindow.addEventListener('mousemove', this.onMouseMove);\n\t\t}\n\t}\n\n\tonMouseDown(event) {}\n\n\tonMouseUp(event) {}\n\n\tonMouseMove(event) {\n\t\tconst w2 = window.innerWidth / 2;\n\t\tconst h2 = window.innerHeight / 2;\n\t\tthis.mouse.x = (event.clientX - w2) / w2;\n\t\tthis.mouse.y = -(event.clientY - h2) / h2;\n\t}\n\n\tonWindowResize(event) {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst width = container.offsetWidth;\n\t\t\tconst height = container.offsetHeight;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(width, height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = width / height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\taddCamera() {\n\t\tconst camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, cm(1), 500);\n\t\tcamera.position.set(0, cm(176), cm(20));\n\t\tcamera.target = new THREE.Vector3(0, cm(156), -cm(60));\n\t\tcamera.onBeforeRender = (renderer, scene) => {\n\t\t\tif (this.vr.mode === VR_MODE.NONE) {\n\t\t\t\t// camera.position.z = Math.cos(this.tick * 0.1) * 1;\n\t\t\t\tcamera.target.set(this.mouse.x * cm(40), cm(156) + this.mouse.y * cm(20), -cm(60) + this.mouse.y * cm(20));\n\t\t\t\tcamera.lookAt(camera.target);\n\t\t\t}\n\t\t};\n\t\treturn camera;\n\t}\n\n\taddControllers(renderer, vr, scene) {\n\t\tif (vr.mode !== VR_MODE.NONE || TEST_ENABLED) {\n\t\t\tconst cube0 = this.cube0;\n\t\t\tconst cube1 = this.cube1;\n\t\t\tconst controllers = new Controllers(renderer, scene, {\n\t\t\t\tdebug: DEBUG\n\t\t\t});\n\t\t\tcontrollers.on('press', (button) => {\n\t\t\t\tconsole.log('vrui.press', button.gamepad.hand, button.index);\n\t\t\t\tswitch (button.gamepad.hand) {\n\t\t\t\t\tcase GAMEPAD_HANDS.LEFT:\n\t\t\t\t\t\t// 0 joystick, 1 trigger, 2 grip, 3 Y, 4 X\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tswitch (button.index) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GAMEPAD_HANDS.RIGHT:\n\t\t\t\t\t\t// 0 joystick, 1 trigger, 2 grip, 3 A, 4 B\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (button.index === 3) {\n\t\t\t\t\tthis.toothbrush.onRespawn();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (TRIGGER_CUBES) {\n\t\t\t\tcontrollers.on('release', (button) => {\n\t\t\t\t\tconsole.log('vrui.release', button.gamepad.hand, button.index);\n\t\t\t\t});\n\t\t\t\tcontrollers.on('left', (axis) => {\n\t\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\t\tconsole.log('vrui.left', axis.gamepad.hand, axis.index);\n\t\t\t\t\t\tTweenMax.to(cube0.userData.rotation, 0.3, {\n\t\t\t\t\t\t\ty: cube0.userData.rotation.y - Math.PI / 2,\n\t\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcontrollers.on('right', (axis) => {\n\t\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\t\tconsole.log('vrui.right', axis.gamepad.hand, axis.index);\n\t\t\t\t\t\tTweenMax.to(cube0.userData.rotation, 0.3, {\n\t\t\t\t\t\t\ty: cube0.userData.rotation.y + Math.PI / 2,\n\t\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcontrollers.on('up', (axis) => {\n\t\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\t\tconsole.log('vrui.up', axis.gamepad.hand, axis.index);\n\t\t\t\t\t\tconst s = Math.min(2.0, cube0.userData.scale.x + 0.1);\n\t\t\t\t\t\tTweenMax.to(cube0.userData.scale, 0.3, {\n\t\t\t\t\t\t\tx: s,\n\t\t\t\t\t\t\ty: s,\n\t\t\t\t\t\t\tz: s,\n\t\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcontrollers.on('down', (axis) => {\n\t\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\t\t\tconsole.log('vrui.down', axis.gamepad.hand, axis.index);\n\t\t\t\t\t\tconst s = Math.max(0.1, cube0.userData.scale.x - 0.1);\n\t\t\t\t\t\tTweenMax.to(cube0.userData.scale, 0.3, {\n\t\t\t\t\t\t\tx: s,\n\t\t\t\t\t\t\ty: s,\n\t\t\t\t\t\t\tz: s,\n\t\t\t\t\t\t\tease: Power2.easeInOut\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcontrollers.on('axis', (axis) => {\n\t\t\t\t\tconsole.log('vrui.axis', axis.gamepad.hand, axis.index);\n\t\t\t\t\tif (axis.gamepad.hand === GAMEPAD_HANDS.RIGHT) {\n\t\t\t\t\t\tconst s = Math.max(0.1, Math.min(2, cube1.scale.x + axis.y * 0.1));\n\t\t\t\t\t\tcube1.userData.scale.set(s, s, s);\n\t\t\t\t\t\tcube1.userData.rotation.y += axis.x * 0.2;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn controllers;\n\t\t}\n\t}\n\n\taddCube(index) {\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-00.jpg');\n\t\tconst geometry = new THREE.BoxGeometry(cm(20), cm(20), cm(20));\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: matcap,\n\t\t});\n\t\tconst mesh = new InteractiveMesh(geometry, material);\n\t\tmesh.position.set(index === 0 ? -cm(30) : cm(30), cm(117), -2);\n\t\tmesh.userData = {\n\t\t\tscale: new THREE.Vector3(1, 1, 1),\n\t\t\trotation: new THREE.Vector3(),\n\t\t\t// position: new THREE.Vector3(),\n\t\t};\n\t\tmesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {\n\t\t\tmesh.scale.set(mesh.userData.scale.x, mesh.userData.scale.y, mesh.userData.scale.z);\n\t\t\tmesh.rotation.set(mesh.userData.rotation.x, mesh.userData.rotation.y, mesh.userData.rotation.z);\n\t\t\t/*\n\t\t\tmesh.rotation.y += Math.PI / 180 * 5;\n\t\t\tmesh.rotation.x += Math.PI / 180 * 1;\n\t\t\tconst s = 1 + Math.cos(this.tick * 0.1) * 0.5;\n\t\t\tmesh.scale.set(s, s, s);\n\t\t\t*/\n\t\t};\n\t\tmesh.on('over', () => {\n\t\t\tmesh.material.color.setHex(0xff0000);\n\t\t});\n\t\tmesh.on('out', () => {\n\t\t\tmesh.material.color.setHex(0x00ff00);\n\t\t});\n\t\tmesh.on('down', () => {\n\t\t\tmesh.material.color.setHex(0x0000ff);\n\t\t});\n\t\tmesh.on('up', () => {\n\t\t\tmesh.material.color.setHex(0xcccccc);\n\t\t});\n\t\treturn mesh;\n\t}\n\n\taddRoundedCube(index) {\n\t\t// const matcap = new THREE.TextureLoader().load('img/matcap/matcap-11.png');\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-06.jpg');\n\t\tconst geometry = new RoundBoxGeometry(cm(20), cm(20), cm(20), cm(4), 1, 1, 1, 3);\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: matcap,\n\t\t\t/*\n\t\t\ttransparent: true,\n\t\t\topacity: 0.4,\n\t\t\tside: THREE.DoubleSide,\n\t\t\t*/\n\t\t});\n\t\tconst mesh = new InteractiveMesh(geometry, material);\n\t\tmesh.position.set(index === 0 ? -cm(30) : cm(30), cm(117), -2);\n\t\tmesh.userData = {\n\t\t\tscale: new THREE.Vector3(1, 1, 1),\n\t\t\trotation: new THREE.Vector3(),\n\t\t};\n\t\tlet box;\n\t\tif (BOUNDING_BOX) {\n\t\t\tbox = new THREE.BoxHelper(mesh, 0x0000ff);\n\t\t\tthis.scene.add(box);\n\t\t}\n\t\tmesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {\n\t\t\tmesh.scale.set(mesh.userData.scale.x, mesh.userData.scale.y, mesh.userData.scale.z);\n\t\t\tmesh.rotation.set(mesh.userData.rotation.x, mesh.userData.rotation.y, mesh.userData.rotation.z);\n\t\t\tmesh.userData.rotation.y += (0.01 + 0.01 * index);\n\t\t\tmesh.userData.rotation.x += (0.01 + 0.01 * index);\n\t\t\tif (box) {\n\t\t\t\tbox.update();\n\t\t\t}\n\t\t};\n\t\tmesh.on('over', () => {\n\t\t\tmesh.material.color.setHex(0xff0000);\n\t\t});\n\t\tmesh.on('out', () => {\n\t\t\tmesh.material.color.setHex(0x00ff00);\n\t\t});\n\t\tmesh.on('down', () => {\n\t\t\tmesh.material.color.setHex(0x0000ff);\n\t\t});\n\t\tmesh.on('up', () => {\n\t\t\tmesh.material.color.setHex(0xffffff);\n\t\t});\n\t\treturn mesh;\n\t}\n\n\taddBanner() {\n\t\tconst texture = new THREE.TextureLoader().load('img/banners/professional-27.png');\n\t\tconst geometry = new THREE.PlaneGeometry(cm(200), cm(200), 2, 2);\n\t\t// geometry.rotateX(Math.PI / 2);\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmap: texture,\n\t\t\ttransparent: true,\n\t\t\t// side: THREE.DoubleSide,\n\t\t});\n\t\tconst mesh = new InteractiveMesh(geometry, material);\n\t\tmesh.position.set(0, cm(200), -6);\n\t\tmesh.on('over', () => {\n\t\t\t// mesh.material.opacity = 0.5;\n\t\t\tTweenMax.to(mesh.material, 0.4, {\n\t\t\t\topacity: 0.8,\n\t\t\t\tease: Power2.easeInOut\n\t\t\t});\n\t\t});\n\t\tmesh.on('out', () => {\n\t\t\t// mesh.material.opacity = 1;\n\t\t\tTweenMax.to(mesh.material, 0.4, {\n\t\t\t\topacity: 1.0,\n\t\t\t\tease: Power2.easeInOut\n\t\t\t});\n\t\t});\n\t\treturn mesh;\n\t}\n\n\taddStand() {\n\t\tconst size = new THREE.Vector3(cm(40), mm(10), cm(20));\n\t\tconst geometry = new RoundBoxGeometry(size.x, size.y, size.z, mm(5), 1, 1, 1, 5);\n\t\tconst mesh = new THREE.Mesh(geometry, this.materials.white);\n\t\tmesh.receiveShadow = true;\n\t\tmesh.position.set(0, cm(116), cm(-60));\n\t\tif (this.physics) {\n\t\t\tthis.physics.addBox(mesh, size);\n\t\t}\n\t\treturn mesh;\n\t}\n\n\taddStand__() {\n\t\t// const matcap = new THREE.TextureLoader().load('img/matcap/matcap-12.jpg');\n\t\t// const matcap = new THREE.TextureLoader().load('img/matcap/matcap-06.jpg');\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-01.jpg');\n\t\t/*\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: matcap,\n\t\t});\n\t\t*/\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmetalness: 0.9,\n\t\t\troughness: 0.05,\n\t\t\t/*\n\t\t\ttransparent: true,\n\t\t\topacity: 0.4,\n\t\t\tside: THREE.DoubleSide,\n\t\t\t*/\n\t\t});\n\t\tconst group = new THREE.Group();\n\t\tgroup.position.set(0, cm(-20), cm(-40));\n\t\tconst path = `models/stand/stand.fbx`;\n\t\tconst loader = new THREE.FBXLoader();\n\t\tloader.load(path, (object) => {\n\t\t\tobject.traverse((child) => {\n\t\t\t\tif (child instanceof THREE.Mesh) {\n\t\t\t\t\tchild.material = material;\n\t\t\t\t\tchild.geometry.rotateX(child.rotation.x);\n\t\t\t\t\tchild.geometry.rotateY(child.rotation.y);\n\t\t\t\t\tchild.geometry.rotateZ(child.rotation.z);\n\t\t\t\t\tchild.rotation.set(0, 0, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t\tgroup.add(object);\n\t\t}, (xhr) => {\n\t\t\tconst progress = xhr.loaded / xhr.total;\n\t\t}, (error) => {\n\t\t\tconsole.log(`model not found ${path}`);\n\t\t});\n\t\treturn group;\n\t}\n\n\taddToothBrush() {\n\t\tconst mesh = new GrabbableGroup();\n\t\tmesh.defaultY = this.stand.position.y + cm(50);\n\t\tmesh.position.set(0, mesh.defaultY, cm(-60));\n\t\tmesh.rotation.set(0, 0, deg(10));\n\t\tconst loader = new THREE.FBXLoader(); // new THREE.OBJLoader();\n\t\tloader.load(`models/toothbrush/professional-27.fbx`, (object) => {\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\tif (child instanceof THREE.Mesh) {\n\t\t\t\t\t\t// child.geometry.scale(2.54, 2.54, 2.54);\n\t\t\t\t\t\tswitch (child.name) {\n\t\t\t\t\t\t\tcase 'body-primary':\n\t\t\t\t\t\t\tcase 'bubble':\n\t\t\t\t\t\t\t\t// child.geometry.computeFaceNormals();\n\t\t\t\t\t\t\t\t// child.geometry.computeVertexNormals(true);\n\t\t\t\t\t\t\t\tchild.material = this.materials.bodyPrimaryClear;\n\t\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\t\tmesh.body = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'body-secondary':\n\t\t\t\t\t\t\t\t// child.geometry.computeFaceNormals();\n\t\t\t\t\t\t\t\t// child.geometry.computeVertexNormals(true);\n\t\t\t\t\t\t\t\tchild.material = this.materials.bodySecondary;\n\t\t\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\t\t\tmesh.color = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'bristles-primary':\n\t\t\t\t\t\t\t\tchild.material = this.materials.bristlesPrimary;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'bristles-secondary':\n\t\t\t\t\t\t\t\tchild.material = this.materials.bristlesSecondary;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'logo':\n\t\t\t\t\t\t\t\tchild.material = this.materials.logoSilver;\n\t\t\t\t\t\t\t\tmesh.logo = child;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmesh.add(object);\n\t\t\t\tif (this.physics) {\n\t\t\t\t\tconst box = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());\n\t\t\t\t\tbox.setFromObject(object);\n\t\t\t\t\tconst size = box.getSize(new THREE.Vector3());\n\t\t\t\t\tmesh.userData.size = size;\n\t\t\t\t\tif (this.physics) {\n\t\t\t\t\t\tthis.physics.addBox(mesh, size, 1);\n\t\t\t\t\t}\n\t\t\t\t\t// this.bodies.push(mesh);\n\t\t\t\t}\n\t\t\t},\n\t\t\t(xhr) => {\n\t\t\t\t// console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.log('An error happened', error);\n\t\t\t});\n\t\tmesh.name = 'toothbrush';\n\t\tmesh.on('grab', (controller) => {\n\t\t\tif (this.physics) {\n\t\t\t\tthis.physics.remove(mesh);\n\t\t\t}\n\t\t\tmesh.userData.speed = 0;\n\t\t\tmesh.falling = false;\n\t\t\tmesh.freeze();\n\t\t\tconst target = controller.parent;\n\t\t\tconst position = mesh.position.clone();\n\t\t\tmesh.parent.localToWorld(position);\n\t\t\ttarget.worldToLocal(position);\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tif (controller.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\tmesh.position.set(cm(1), cm(2), cm(0));\n\t\t\t\tmesh.rotation.set(deg(180), deg(0), deg(115));\n\t\t\t} else {\n\t\t\t\tmesh.position.set(cm(-1), cm(3), cm(-1));\n\t\t\t\tmesh.rotation.set(0, deg(10), deg(-60));\n\t\t\t}\n\t\t\ttarget.add(mesh);\n\t\t\tTweenMax.to(controller.material, 0.4, {\n\t\t\t\topacity: 0.0,\n\t\t\t\tease: Power2.easeInOut,\n\t\t\t});\n\t\t});\n\t\tmesh.on('release', (controller) => {\n\t\t\tconst target = this.scene;\n\t\t\tconst position = mesh.position.clone(); // new THREE.Vector3();\n\t\t\tconst quaternion = mesh.parent.quaternion.clone();\n\t\t\tmesh.parent.localToWorld(position);\n\t\t\ttarget.worldToLocal(position);\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tmesh.position.set(0, 0, 0);\n\t\t\tmesh.quaternion.premultiply(quaternion);\n\t\t\tmesh.position.set(position.x, position.y, position.z);\n\t\t\ttarget.add(mesh);\n\t\t\tmesh.unfreeze();\n\t\t\tTweenMax.to(controller.material, 0.4, {\n\t\t\t\topacity: 1.0,\n\t\t\t\tease: Power2.easeInOut\n\t\t\t});\n\t\t\tif (this.physics) {\n\t\t\t\tif (TEST_ENABLED) {\n\t\t\t\t\tthis.linearVelocity.z -= 1;\n\t\t\t\t}\n\t\t\t\tthis.physics.addBox(mesh, mesh.userData.size, 1, this.linearVelocity, this.angularVelocity);\n\t\t\t\t/*\n\t\t\t\tthis.bodies.push(mesh);\n\t\t\t\tbody.setCollisionFlags(1); // 0 is static 1 dynamic 2 kinematic and state to 4:\n\t\t\t\tbody.setActivationState(1); // never sleep\n\t\t\t\t*/\n\t\t\t} else {\n\t\t\t\tmesh.falling = true;\n\t\t\t}\n\t\t});\n\t\tmesh.onRespawn = () => {\n\t\t\tif (this.physics) {\n\t\t\t\tthis.physics.remove(mesh);\n\t\t\t}\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tsetTimeout(() => {\n\t\t\t\tmesh.position.set(0, mesh.defaultY, cm(-60));\n\t\t\t\tmesh.rotation.set(0, 0, deg(10));\n\t\t\t\tthis.scene.add(mesh);\n\t\t\t\tif (this.physics) {\n\t\t\t\t\tthis.physics.addBox(mesh, mesh.userData.size, 1);\n\t\t\t\t\t// this.bodies.push(mesh);\n\t\t\t\t}\n\t\t\t}, 1000);\n\t\t};\n\t\tmesh.userData.respawn = (data) => {\n\t\t\tif (mesh.position.y < cm(30)) {\n\t\t\t\t// const linearVelocity = mesh.userData.body.getLinearVelocity();\n\t\t\t\t// if (linearVelocity.length() < 0.03) {\n\t\t\t\tif (data && data.speed < 0.03) {\n\t\t\t\t\tmesh.onRespawn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t/*\n\t\tconst onRespawn = () => {\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tmesh.falling = false;\n\t\t\tsetTimeout(() => {\n\t\t\t\tmesh.position.set(0, mesh.defaultY, cm(-60));\n\t\t\t\tmesh.rotation.set(0, 0, 0);\n\t\t\t\tthis.scene.add(mesh);\n\t\t\t}, 1000);\n\t\t};\n\t\tconst onFallDown = () => {\n\t\t\tif (mesh.falling) {\n\t\t\t\tconst speed = mesh.userData.speed || mm(0.1);\n\t\t\t\tlet tx = mesh.position.x;\n\t\t\t\tlet ty = mesh.position.y;\n\t\t\t\tlet tz = mesh.position.z;\n\t\t\t\tlet rx = mesh.rotation.x;\n\t\t\t\tlet ry = mesh.rotation.y;\n\t\t\t\tlet rz = mesh.rotation.z;\n\t\t\t\tty -= speed;\n\t\t\t\trx += (0 - rx) / 1000 * speed;\n\t\t\t\try += (0 - ry) / 1000 * speed;\n\t\t\t\trz += deg(0.05) * speed;\n\t\t\t\tmesh.position.set(tx, ty, tz);\n\t\t\t\tmesh.rotation.set(rx, ry, rz);\n\t\t\t\tmesh.userData.speed = speed * 1.1;\n\t\t\t\tif (ty < cm(-30)) {\n\t\t\t\t\tonRespawn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t*/\n\t\t/*\n\t\tlet box;\n\t\tif (BOUNDING_BOX) {\n\t\t\tbox = new THREE.BoxHelper(mesh, 0x0000ff);\n\t\t\tthis.scene.add(box);\n\t\t}\n\t\tmesh.onUpdate = (renderer, scene, camera, object, delta, time, tick) => {\n\t\t\tif (box && !mesh.freezed) {\n\t\t\t\tbox.update();\n\t\t\t}\n\t\t\tonFallDown();\n\t\t};\n\t\t*/\n\t\treturn mesh;\n\t}\n\n\taddToothBrush__() {\n\t\t// const matcap = new THREE.TextureLoader().load('img/matcap/matcap-06.jpg');\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-11.png');\n\t\tconst geometry = new RoundBoxGeometry(cm(18), mm(6), cm(1), mm(3), 1, 1, 1, 3);\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: matcap,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.4,\n\t\t\tside: THREE.DoubleSide,\n\n\t\t});\n\t\tconst mesh = new InteractiveMesh(geometry, material);\n\t\tmesh.position.set(0, cm(117), cm(-60));\n\t\tmesh.name = 'toothbrush';\n\n\t\tconst bristlesGeometry = new RoundBoxGeometry(cm(2), mm(12), cm(1), mm(2), 1, 1, 1, 3);\n\t\tconst bristlesMesh = new THREE.Mesh(bristlesGeometry, material);\n\t\tbristlesMesh.position.set(-cm(8), mm(9), 0);\n\t\tmesh.add(bristlesMesh);\n\n\t\tmesh.on('grab', (controller) => {\n\t\t\tmesh.userData.speed = 0;\n\t\t\tmesh.falling = false;\n\t\t\tmesh.freeze();\n\t\t\tconst target = controller.parent;\n\t\t\t// target.updateMatrixWorld();\n\t\t\tconst position = mesh.position.clone(); // new THREE.Vector3();\n\t\t\tmesh.parent.localToWorld(position);\n\t\t\ttarget.worldToLocal(position);\n\t\t\tmesh.parent.remove(mesh);\n\t\t\t// mesh.position.set(position.x, position.y, position.z);\n\t\t\tif (controller.gamepad.hand === GAMEPAD_HANDS.LEFT) {\n\t\t\t\tmesh.position.set(cm(1), cm(2), cm(0));\n\t\t\t\tmesh.rotation.set(deg(180), deg(0), deg(115));\n\t\t\t} else {\n\t\t\t\tmesh.position.set(cm(-1), cm(3), cm(-1));\n\t\t\t\tmesh.rotation.set(0, deg(10), deg(-60));\n\t\t\t}\n\t\t\ttarget.add(mesh);\n\t\t\tTweenMax.to(controller.material, 0.4, {\n\t\t\t\topacity: 0.0,\n\t\t\t\tease: Power2.easeInOut,\n\t\t\t});\n\t\t\t// console.log('grab', position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2));\n\t\t\t// console.log(target.name);\n\t\t});\n\t\tmesh.on('release', (controller) => {\n\t\t\tconst target = this.scene;\n\t\t\t// target.updateMatrixWorld();\n\t\t\t// mesh.parent.updateMatrixWorld();\n\t\t\tconst position = mesh.position.clone(); // new THREE.Vector3();\n\t\t\tconst quaternion = mesh.parent.quaternion.clone();\n\t\t\tmesh.parent.localToWorld(position);\n\t\t\ttarget.worldToLocal(position);\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tmesh.position.set(0, 0, 0);\n\t\t\tmesh.quaternion.premultiply(quaternion);\n\t\t\tmesh.position.set(position.x, position.y, position.z);\n\t\t\ttarget.add(mesh);\n\t\t\tmesh.unfreeze();\n\t\t\tmesh.falling = true;\n\t\t\tTweenMax.to(controller.material, 0.4, {\n\t\t\t\topacity: 1.0,\n\t\t\t\tease: Power2.easeInOut\n\t\t\t});\n\t\t\t// console.log('release', position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2));\n\t\t\t// console.log(target.name);\n\t\t});\n\t\t/*\n\t\tmesh.userData = {\n\t\t\tscale: new THREE.Vector3(1, 1, 1),\n\t\t\trotation: new THREE.Vector3(),\n\t\t};\n\t\tmesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {\n\t\t\tmesh.scale.set(mesh.userData.scale.x, mesh.userData.scale.y, mesh.userData.scale.z);\n\t\t\tmesh.rotation.set(mesh.userData.rotation.x, mesh.userData.rotation.y, mesh.userData.rotation.z);\n\t\t\tmesh.userData.rotation.y += (0.01 + 0.01 * index);\n\t\t\tmesh.userData.rotation.x += (0.01 + 0.01 * index);\n\t\t};\n\t\t*/\n\t\tconst onRespawn = () => {\n\t\t\tmesh.parent.remove(mesh);\n\t\t\tmesh.falling = false;\n\t\t\tsetTimeout(() => {\n\t\t\t\tmesh.position.set(0, cm(117), cm(-60));\n\t\t\t\tmesh.rotation.set(0, 0, 0);\n\t\t\t\tthis.scene.add(mesh);\n\t\t\t\t// console.log('onRespawn.scened');\n\t\t\t}, 1000);\n\t\t\t// console.log('onRespawn');\n\t\t};\n\t\t/*\n\t\tconst onFallDown = () => {\n\t\t\tif (mesh.falling) {\n\t\t\t\tconst speed = mesh.userData.speed || mm(0.1);\n\t\t\t\tlet tx = mesh.position.x;\n\t\t\t\tlet ty = mesh.position.y;\n\t\t\t\tlet tz = mesh.position.z;\n\t\t\t\tlet rx = mesh.rotation.x;\n\t\t\t\tlet ry = mesh.rotation.y;\n\t\t\t\tlet rz = mesh.rotation.z;\n\t\t\t\tty -= speed;\n\t\t\t\trx += (0 - rx) / 1000 * speed;\n\t\t\t\try += (0 - ry) / 1000 * speed;\n\t\t\t\trz += deg(0.05) * speed;\n\t\t\t\tmesh.position.set(tx, ty, tz);\n\t\t\t\tmesh.rotation.set(rx, ry, rz);\n\t\t\t\tmesh.userData.speed = speed * 1.1;\n\t\t\t\tif (ty < cm(-30)) {\n\t\t\t\t\tonRespawn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t*/\n\t\tlet box;\n\t\tif (BOUNDING_BOX) {\n\t\t\tbox = new THREE.BoxHelper(mesh, 0x0000ff);\n\t\t\tthis.scene.add(box);\n\t\t}\n\t\tmesh.onUpdate = (renderer, scene, camera, object, delta, time, tick) => {\n\t\t\tif (box && !mesh.freezed) {\n\t\t\t\tbox.update();\n\t\t\t}\n\t\t\t// onFallDown();\n\t\t};\n\t\treturn mesh;\n\t}\n\n\tcheckCameraPosition__() {\n\t\tconst tick = this.tick;\n\t\tconst camera = this.camera;\n\t\tconst controllers = this.controllers;\n\t\tconst stand = this.stand;\n\t\tconst toothbrush = this.toothbrush;\n\t\tconst y = camera.position.y;\n\t\tif (y < 1.2 && stand.position.y === cm(116)) {\n\t\t\tstand.position.y = y - cm(40);\n\t\t\ttoothbrush.defaultY = stand.position.y + cm(50);\n\t\t\ttoothbrush.position.y = toothbrush.defaultY;\n\t\t}\n\t\tif (tick % 120 === 0 && controllers) {\n\t\t\tcontrollers.setText(`camera ${y.toFixed(3)}`);\n\t\t}\n\t}\n\n\taddBG() {\n\t\tconst matcap = new THREE.TextureLoader().load('img/matcap/matcap-10.jpg');\n\t\tconst geometry = new THREE.Geometry();\n\t\tconst origin = new THREE.Vector3();\n\t\tnew Array(300).fill().forEach(x => {\n\t\t\tconst s = cm(30) + Math.random() * cm(0);\n\t\t\tconst h = 3.0 + Math.random() * 3.0;\n\t\t\tconst r = 5 + Math.random() * 20;\n\t\t\tconst a = Math.PI * 2 * Math.random();\n\t\t\t// const cubeGeometry = new THREE.BoxGeometry(s, h, s);\n\t\t\tconst cubeBufferGeometry = new RoundBoxGeometry(s, h, s, cm(4),\n\t\t\t\t1, 1, 1, 3);\n\t\t\tconst cubeGeometry = new THREE.Geometry().fromBufferGeometry(cubeBufferGeometry);\n\t\t\tcubeGeometry.translate(Math.cos(a) * r, h / 2, Math.sin(a) * r);\n\t\t\tcubeGeometry.lookAt(origin);\n\t\t\tgeometry.merge(cubeGeometry);\n\t\t});\n\t\tconst bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0x333333,\n\t\t\tmatcap: matcap,\n\t\t});\n\t\tconst mesh = new THREE.Mesh(bufferGeometry, material);\n\t\t/*\n\t\tmesh.onBeforeRender = () => {\n\t\t\tmesh.rotation.y += 0.001;\n\t\t};\n\t\t*/\n\t\treturn mesh;\n\t}\n\n\taddSceneBackground(renderer, scene, callback) {\n\t\tconst loader = new THREE.TextureLoader().load('img/environment/equirectangular.jpg', (source, textureData) => {\n\t\t\t// const loader = new THREE.TextureLoader().load('img/environment/360_world.jpg', (source, textureData) => {\n\t\t\tsource.mapping = THREE.UVMapping;\n\t\t\tconst options = {\n\t\t\t\tresolution: 1024,\n\t\t\t\tgenerateMipmaps: true,\n\t\t\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter\n\t\t\t};\n\t\t\tscene.background = new THREE.CubemapGenerator(renderer).fromEquirectangular(source, options);\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tconst cubemapGenerator = new THREE.EquirectangularToCubeGenerator(source, options);\n\t\t\t\tconst texture = cubemapGenerator.update(renderer);\n\t\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\t\ttexture.mapping = THREE.CubeRefractionMapping;\n\t\t\t\tsource.dispose();\n\t\t\t\tcallback(texture);\n\t\t\t}\n\t\t});\n\t\treturn loader;\n\t}\n\n\tupdateRaycaster() {\n\t\ttry {\n\t\t\tconst controllers = this.controllers;\n\t\t\tconst raycaster = controllers.setRaycaster(this.raycaster);\n\t\t\tif (raycaster) {\n\t\t\t\tconst hit = InteractiveMesh.hittest(raycaster, controllers.gamepads.button, controllers.controller);\n\t\t\t\tif (hit) {\n\t\t\t\t\tcontrollers.feedback();\n\t\t\t\t\t/*\n\t\t\t\t\tif (Tone.context.state === 'running') {\n\t\t\t\t\t\tconst feedback = this.feedback = (this.feedback || new Tone.Player('audio/feedback.mp3').toMaster());\n\t\t\t\t\t\tfeedback.start();\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\tGrabbableGroup.grabtest(controllers);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\trender() {\n\t\ttry {\n\t\t\tconst delta = this.clock.getDelta();\n\t\t\tconst time = this.clock.getElapsedTime();\n\t\t\tconst tick = Math.floor(time * 60);\n\t\t\tif (this.physics) {\n\t\t\t\tthis.physics.update(delta);\n\t\t\t}\n\t\t\tconst renderer = this.renderer;\n\t\t\tconst scene = this.scene;\n\t\t\tconst camera = this.camera;\n\t\t\tFreezableMesh.update(renderer, scene, camera, delta, time, tick);\n\t\t\tFreezableGroup.update(renderer, scene, camera, delta, time, tick);\n\t\t\tif (this.controllers) {\n\t\t\t\tthis.controllers.update();\n\t\t\t\tthis.updateRaycaster();\n\t\t\t\t// this.checkCameraPosition__();\n\t\t\t\tif (this.physics) {\n\t\t\t\t\tthis.updateVelocity(this.controllers.controller);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcamera.onBeforeRender(renderer, scene);\n\t\t\trenderer.render(scene, camera);\n\t\t\tthis.delta = delta;\n\t\t\tthis.time = time;\n\t\t\tthis.tick = tick;\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() => {\n\t\t\tthis.render();\n\t\t});\n\t}\n\n}\n\nconst instance = new Vrui();\ninstance.animate();\n"],"file":"docs/js/vrui.js"}